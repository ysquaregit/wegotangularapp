/**
 * angular-gauge - A tiny angular 4.0+ wrapper for https://github.com/naikus/svg-gauge
 * @version v2.0.1
 * @author Matt Lewis
 * @link https://github.com/mattlewis92/angular-gauge#readme
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@angular/core"));
	else if(typeof define === 'function' && define.amd)
		define(["@angular/core"], factory);
	else if(typeof exports === 'object')
		exports["angularGauge"] = factory(require("@angular/core"));
	else
		root["angularGauge"] = factory(root["ng"]["core"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GaugeDefaults = (function () {
    function GaugeDefaults() {
        /**
         * The angle in degrees to start the dial
         */
        this.dialStartAngle = 135;
        /**
         * The angle in degrees to end the dial. This MUST be less than dialStartAngle
         */
        this.dialEndAngle = 45;
        /**
         * The radius of the gauge
         */
        this.radius = 400;
        /**
         * The maximum value for the gauge
         */
        this.max = 100;
        /**
         * Whether to show the value at the center of the gauge
         */
        this.showValue = true;
        /**
         * The CSS class of the gauge
         */
        this.gaugeClass = 'gauge';
        /**
         * The CSS class of the gauge's dial
         */
        this.dialClass = 'dial';
        /**
         * The CSS class of the gauge's fill (value dial)
         */
        this.valueDialClass = 'value';
        /**
         * 	The CSS class of the gauge's text
         */
        this.valueTextClass = 'value-text';
        /**
         * Whether to animate changing the gauge
         */
        this.animated = false;
    }
    return GaugeDefaults;
}());
exports.GaugeDefaults = GaugeDefaults;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(1);
var gauge_component_1 = __webpack_require__(3);
var gauge_defaults_service_1 = __webpack_require__(0);
exports.USER_DEFAULTS = new core_1.InjectionToken('gauge defaults');
function defaultsFactory(userDefaults) {
    var defaults = new gauge_defaults_service_1.GaugeDefaults();
    Object.assign(defaults, userDefaults);
    return defaults;
}
exports.defaultsFactory = defaultsFactory;
var GaugeModule = GaugeModule_1 = (function () {
    function GaugeModule() {
    }
    GaugeModule.forRoot = function (userDefaults) {
        if (userDefaults === void 0) { userDefaults = {}; }
        return {
            ngModule: GaugeModule_1,
            providers: [{
                    provide: exports.USER_DEFAULTS,
                    useValue: userDefaults
                }, {
                    provide: gauge_defaults_service_1.GaugeDefaults,
                    useFactory: defaultsFactory,
                    deps: [exports.USER_DEFAULTS]
                }]
        };
    };
    return GaugeModule;
}());
GaugeModule = GaugeModule_1 = __decorate([
    core_1.NgModule({
        declarations: [
            gauge_component_1.GaugeComponent
        ],
        exports: [
            gauge_component_1.GaugeComponent
        ]
    })
], GaugeModule);
exports.GaugeModule = GaugeModule;
var GaugeModule_1;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(1);
var Gauge = __webpack_require__(5);
var gauge_defaults_service_1 = __webpack_require__(0);
var GaugeComponent = (function () {
    function GaugeComponent(elm, defaults) {
        this.elm = elm;
        this.defaults = defaults;
        /**
         * Called when the gauge is created
         */
        this.gaugeCreated = new core_1.EventEmitter();
    }
    GaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var options = {
            dialStartAngle: this.dialStartAngle,
            dialEndAngle: this.dialEndAngle,
            radius: this.radius,
            max: this.max,
            label: this.label,
            showValue: this.showValue,
            gaugeClass: this.gaugeClass,
            dialClass: this.dialClass,
            valueDialClass: this.valueDialClass,
            valueTextClass: this.valueTextClass,
            value: this.value
        };
        Object.keys(this.defaults).forEach(function (optionKey) {
            if (typeof options[optionKey] === 'undefined') {
                options[optionKey] = _this.defaults[optionKey];
            }
        });
        Object.keys(options).forEach(function (optionKey) {
            if (typeof options[optionKey] === 'undefined') {
                delete options[optionKey];
            }
        });
        this.gauge = Gauge(this.elm.nativeElement, options);
        this.gaugeCreated.emit({ gauge: this.gauge });
        this.updateValue();
    };
    GaugeComponent.prototype.ngOnChanges = function (changes) {
        if (changes['value']) {
            this.updateValue();
        }
    };
    GaugeComponent.prototype.updateValue = function () {
        if (this.gauge) {
            if (this.animated) {
                this.gauge.setValueAnimated(this.value, this.animationDuration);
            }
            else {
                this.gauge.setValue(this.value);
            }
        }
    };
    return GaugeComponent;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "dialStartAngle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "dialEndAngle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "radius", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "max", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], GaugeComponent.prototype, "label", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], GaugeComponent.prototype, "showValue", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], GaugeComponent.prototype, "gaugeClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], GaugeComponent.prototype, "dialClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], GaugeComponent.prototype, "valueDialClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], GaugeComponent.prototype, "valueTextClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], GaugeComponent.prototype, "animated", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "animationDuration", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GaugeComponent.prototype, "gaugeCreated", void 0);
GaugeComponent = __decorate([
    core_1.Component({
        selector: 'mwl-gauge',
        template: ''
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, gauge_defaults_service_1.GaugeDefaults])
], GaugeComponent);
exports.GaugeComponent = GaugeComponent;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(2));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6);


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, define, module */
(function(global, factory) {
  var Gauge = factory(global);
  if(true) {
    // AMD support
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return Gauge;}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }else if(typeof module === "object" && module.exports) {
    // CommonJS support
    module.exports = Gauge;
  }else {
    // We are probably running in the browser
    global.Gauge = Gauge;
  }
})(typeof window === "undefined" ? this : window, function(global, undefined) {

  var document = global.document,
    requestAnimationFrame = (global.requestAnimationFrame ||
        global.mozRequestAnimationFrame ||
        global.webkitRequestAnimationFrame ||
        global.msRequestAnimationFrame ||
        function(cb) {
          return setTimeout(cb, 1000 / 60);
        });

  // EXPERIMENTAL!!
  /**
   * Simplistic animation function for animating the gauge. That's all!
   * Options are:
   * {
   *  duration: 1,    // In seconds
   *  start: 0,       // The start value
   *  end: 100,       // The end value
   *  step: function, // REQUIRED! The step function that will be passed the value and does something
   *  easing: function // The easing function. Default is easeInOutCubic
   * }
   */
  function Animation(options) {
    var duration = options.duration,
        currentIteration = 1,
        iterations = 60 * duration,
        start = options.start || 0,
        end = options.end,
        change = end - start,
        step = options.step,
        easing = options.easing || function easeInOutCubic(pos) {
          // https://github.com/danro/easing-js/blob/master/easing.js
          if ((pos/=0.5) < 1) return 0.5*Math.pow(pos,3);
          return 0.5 * (Math.pow((pos-2),3) + 2);
        };

    function animate() {
      var progress = (currentIteration++) / iterations;
      var value = change * easing(progress) + start;
      // console.log(progress + ", " + value);
      step(value);
      if(progress < 1) {
        requestAnimationFrame(animate);
      }
    }
    // start!
    requestAnimationFrame(animate);
  }



  var Gauge = (function() {

    var SVG_NS = "http://www.w3.org/2000/svg";

    var GaugeDefaults = {
      dialStartAngle: 135,
      dialEndAngle: 45,
      centerX: 500,
      centerY: 500,
      radius: 400
    };

    /**
     * A utility function to create SVG dom tree
     * @param {String} name The SVG element name
     * @param {Object} attrs The attributes as they appear in DOM e.g. stroke-width and not strokeWidth
     * @param {Array} children An array of children (can be created by this same function)
     * @return The SVG element
     */
    function svg(name, attrs, children) {
      var elem = document.createElementNS(SVG_NS, name);
      for(var attrName in attrs) {
        elem.setAttribute(attrName, attrs[attrName]);
      }

      if(children) {
        children.forEach(function(c) {
          elem.appendChild(c);
        });
      }
      return elem;
    }

    /**
     * Translates percentage value to angle. e.g. If gauge span angle is 180deg, then 50%
     * will be 90deg
     */
    function getAngle(percentage, gaugeSpanAngle) {
      return percentage * gaugeSpanAngle / 100;
    }

    function normalize(value, limit) {
      var val = Number(value);
      if(val > limit) return limit;
      if(val < 0) return 0;
      return val;
    }

    function getValueInPercentage(value, limit) {
      return 100 * value / limit;
    }

    /**
     * Gets cartesian co-ordinates for a specified radius and angle (in degrees)
     * @param cx {Number} The center x co-oriinate
     * @param cy {Number} The center y co-ordinate
     * @param radius {Number} The radius of the circle
     * @param angle {Number} The angle in degrees
     * @return An object with x,y co-ordinates
     */
    function getCartesian(cx, cy, radius, angle) {
      var rad = angle * Math.PI / 180;
      return {
        x: Math.round((cx + radius * Math.cos(rad)) * 1000) / 1000,
        y: Math.round((cy + radius * Math.sin(rad)) * 1000) / 1000
      };
    }

    // Returns start and end points for dial
    // i.e. starts at 135deg ends at 45deg with large arc flag
    // REMEMBER!! angle=0 starts on X axis and then increases clockwise
    function getDialCoords(radius, startAngle, endAngle) {
      var cx = GaugeDefaults.centerX,
          cy = GaugeDefaults.centerY;
      return {
        end: getCartesian(cx, cy, radius, endAngle),
      	start: getCartesian(cx, cy, radius, startAngle)
      };
    }

    function defaultLabelRenderer(theValue) {
      return Math.round(theValue);
    }

    /**
     * Creates a Gauge object. This should be called without the 'new' operator. Various options
     * can be passed for the gauge:
     * {
     *    dialStartAngle: The angle to start the dial. MUST be greater than dialEndAngle. Default 135deg
     *    dialEndAngle: The angle to end the dial. Default 45deg
     *    radius: The gauge's radius. Default 400
     *    max: The maximum value of the gauge. Default 100
     *    value: The starting value of the gauge. Default 0
     *    label: The function on how to render the center label (Should return a value)
     * }
     * @param {Element} elem The DOM into which to render the gauge
     * @param {Object} opts The gauge options
     * @return a Gauge object
     */
    return function Gauge(elem, opts) {
      opts = opts || {};
      var gaugeContainer = elem,
          limit = opts.max || 100,
          value = normalize(opts.value || 0, limit),
          radius = opts.radius || 400,
          displayValue = opts.showValue === false ? false : true,
          valueLabelRender = typeof (opts.label) === "function" ? opts.label : defaultLabelRenderer,
          startAngle = typeof (opts.dialStartAngle) === "undefined" ? 135 : opts.dialStartAngle,
          endAngle = typeof (opts.dialEndAngle) === "undefined" ? 45 : opts.dialEndAngle,
          valueDialClass = typeof (opts.valueDialClass) === "undefined" ? 'value' : opts.valueDialClass,
          valueTextClass = typeof (opts.valueTextClass) === "undefined" ? 'value-text' : opts.valueTextClass,
          dialClass = typeof (opts.dialClass) === "undefined" ? 'dial' : opts.dialClass,
          gaugeClass = typeof (opts.gaugeClass) === "undefined" ? 'gauge' : opts.gaugeClass,
          gaugeTextElem,
          gaugeValuePath,
          instance;

      if(startAngle < endAngle) {
        console.log("WARNING! Start angle should be greater than end angle. Swapping");
        var tmp = startAngle;
        startAngle = endAngle;
        endAngle = tmp;
      }

      function pathString(radius, startAngle, endAngle, largeArc) {
        var coords = getDialCoords(radius, startAngle, endAngle),
            start = coords.start,
            end = coords.end,
            largeArcFlag = typeof(largeArc) === "undefined" ? 1 : largeArc;

        return ["M", start.x, start.y, "A", radius, radius, "0", largeArcFlag, "1", end.x, end.y].join(" ");
      }

      function initializeGauge(elem) {
        gaugeTextElem = svg("text", {
          "class": valueTextClass,
          "x": 500,
          "y": 550,
          "font-size": "700%",
          "font-family": "sans-serif",
          "font-weight": "bold",
          "text-anchor": "middle"
        });
        gaugeValuePath = svg("path", {
          "class": valueDialClass,
          "fill": "transparent",
          "stroke": "#666",
          "stroke-width": 25,
          "d": pathString(radius, startAngle, startAngle) // value of 0
        });

        var angle = getAngle(100, 360 - Math.abs(startAngle - endAngle));
        var flag = angle <= 180 ? 0 : 1;
        var gaugeElement = svg("svg", {"viewBox": "0 0 1000 1000", "class": gaugeClass},
          [
            svg("path", {
              "class": dialClass,
              "fill": "transparent",
              "stroke": "#eee",
              "stroke-width": 20,
              "d": pathString(radius, startAngle, endAngle, flag)
            }),
            gaugeTextElem,
            gaugeValuePath
          ]
        );
        elem.appendChild(gaugeElement);
      }

      function updateGauge(theValue) {
        var val = getValueInPercentage(theValue, limit),
            // angle = getAngle(val, 360 - Math.abs(endAngle - startAngle)),
            angle = getAngle(val, 360 - Math.abs(startAngle - endAngle)),
            // this is because we are using arc greater than 180deg
            flag = angle <= 180 ? 0 : 1;
        (displayValue && (gaugeTextElem.textContent = valueLabelRender.call(opts, theValue)));
        gaugeValuePath.setAttribute("d", pathString(radius, startAngle, angle + startAngle, flag));
      }

      instance = {
        setMaxValue: function(max) {
          limit = max;
        },
        setValue: function(val) {
          value = normalize(val, limit);
          updateGauge(value);
        },
        setValueAnimated: function(val, duration) {
        	var oldVal = value;
          value = normalize(val, limit);
          if(oldVal === value) {
            return;
          }
          Animation({
            start: oldVal || 0,
            end: value,
            duration: duration || 1,
            step: function(val) {
              updateGauge(Math.round(val * 100) / 100);
            }
          });
        },
        getValue: function() {
          return value;
        }
      };

      initializeGauge(gaugeContainer);
      updateGauge(value);
      return instance;
    };
  })();

  return Gauge;
});


/***/ })
/******/ ]);
});
//# sourceMappingURL=angular-gauge.umd.js.map